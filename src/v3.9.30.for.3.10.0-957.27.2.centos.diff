diff --git a/bundle/fs/nfsd/nfs4proc.c b/bundle/fs/nfsd/nfs4proc.c
index 7daa1dac4..145fb8b26 100644
--- a/bundle/fs/nfsd/nfs4proc.c
+++ b/bundle/fs/nfsd/nfs4proc.c
@@ -1003,6 +1003,9 @@ nfsd4_verify_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 {
 	__be32 status;
 
+	if (!cstate->save_fh.fh_dentry)
+		return nfserr_nofilehandle;
+
 	status = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->save_fh,
 					    src_stateid, RD_STATE, src, NULL);
 	if (status) {
diff --git a/bundle/fs/nfsd/nfs4state.c b/bundle/fs/nfsd/nfs4state.c
index 5797963dc..658a3a1c7 100644
--- a/bundle/fs/nfsd/nfs4state.c
+++ b/bundle/fs/nfsd/nfs4state.c
@@ -3989,7 +3989,8 @@ static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, statei
 {
 	struct nfs4_stid *ret;
 
-	ret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);
+	ret = find_stateid_by_type(cl, s,
+				NFS4_DELEG_STID|NFS4_REVOKED_DELEG_STID);
 	if (!ret)
 		return NULL;
 	return delegstateid(ret);
@@ -4012,6 +4013,12 @@ nfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,
 	deleg = find_deleg_stateid(cl, &open->op_delegate_stateid);
 	if (deleg == NULL)
 		goto out;
+	if (deleg->dl_stid.sc_type == NFS4_REVOKED_DELEG_STID) {
+		nfs4_put_stid(&deleg->dl_stid);
+		if (cl->cl_minorversion)
+			status = nfserr_deleg_revoked;
+		goto out;
+	}
 	flags = share_access_to_flags(open->op_share_access);
 	status = nfs4_check_delegmode(deleg, flags);
 	if (status) {
@@ -4893,6 +4900,16 @@ nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,
 		     struct nfs4_stid **s, struct nfsd_net *nn)
 {
 	__be32 status;
+	bool return_revoked = false;
+
+	/*
+	 *  only return revoked delegations if explicitly asked.
+	 *  otherwise we report revoked or bad_stateid status.
+	 */
+	if (typemask & NFS4_REVOKED_DELEG_STID)
+		return_revoked = true;
+	else if (typemask & NFS4_DELEG_STID)
+		typemask |= NFS4_REVOKED_DELEG_STID;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
 		return nfserr_bad_stateid;
@@ -4907,6 +4924,12 @@ nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,
 	*s = find_stateid_by_type(cstate->clp, stateid, typemask);
 	if (!*s)
 		return nfserr_bad_stateid;
+	if (((*s)->sc_type == NFS4_REVOKED_DELEG_STID) && !return_revoked) {
+		nfs4_put_stid(*s);
+		if (cstate->minorversion)
+			return nfserr_deleg_revoked;
+		return nfserr_bad_stateid;
+	}
 	return nfs_ok;
 }
 
diff --git a/bundle/include/linux/nfs.h b/bundle/include/linux/nfs.h
deleted file mode 100644
index 610af5155..000000000
--- a/bundle/include/linux/nfs.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * NFS protocol definitions
- *
- * This file contains constants mostly for Version 2 of the protocol,
- * but also has a couple of NFSv3 bits in (notably the error codes).
- */
-#ifndef _LINUX_NFS_H
-#define _LINUX_NFS_H
-
-#include <linux/sunrpc/msg_prot.h>
-#include <linux/string.h>
-#include <uapi/linux/nfs.h>
-
-/*
- * This is the kernel NFS client file handle representation
- */
-#define NFS_MAXFHSIZE		128
-struct nfs_fh {
-	unsigned short		size;
-	unsigned char		data[NFS_MAXFHSIZE];
-};
-
-/*
- * Returns a zero iff the size and data fields match.
- * Checks only "size" bytes in the data field.
- */
-static inline int nfs_compare_fh(const struct nfs_fh *a, const struct nfs_fh *b)
-{
-	return a->size != b->size || memcmp(a->data, b->data, a->size) != 0;
-}
-
-static inline void nfs_copy_fh(struct nfs_fh *target, const struct nfs_fh *source)
-{
-	target->size = source->size;
-	memcpy(target->data, source->data, source->size);
-}
-
-
-/*
- * This is really a general kernel constant, but since nothing like
- * this is defined in the kernel headers, I have to do it here.
- */
-#define NFS_OFFSET_MAX		((__s64)((~(__u64)0) >> 1))
-
-
-enum nfs3_stable_how {
-	NFS_UNSTABLE = 0,
-	NFS_DATA_SYNC = 1,
-	NFS_FILE_SYNC = 2,
-
-	/* used by direct.c to mark verf as invalid */
-	NFS_INVALID_STABLE_HOW = -1
-};
-#endif /* _LINUX_NFS_H */
diff --git a/bundle/include/linux/nfs3.h b/bundle/include/linux/nfs3.h
deleted file mode 100644
index a778ad8e3..000000000
--- a/bundle/include/linux/nfs3.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * NFSv3 protocol definitions
- */
-#ifndef _LINUX_NFS3_H
-#define _LINUX_NFS3_H
-
-#include <uapi/linux/nfs3.h>
-
-
-/* Number of 32bit words in post_op_attr */
-#define NFS3_POST_OP_ATTR_WORDS		22
-
-#endif /* _LINUX_NFS3_H */
diff --git a/bundle/include/linux/nfs4.h b/bundle/include/linux/nfs4.h
deleted file mode 100644
index ce38d755b..000000000
--- a/bundle/include/linux/nfs4.h
+++ /dev/null
@@ -1,642 +0,0 @@
-/*
- *  include/linux/nfs4.h
- *
- *  NFSv4 protocol definitions.
- *
- *  Copyright (c) 2002 The Regents of the University of Michigan.
- *  All rights reserved.
- *
- *  Kendrick Smith <kmsmith@umich.edu>
- *  Andy Adamson   <andros@umich.edu>
- */
-#ifndef _LINUX_NFS4_H
-#define _LINUX_NFS4_H
-
-#include <linux/list.h>
-#include <linux/uidgid.h>
-#include <uapi/linux/nfs4.h>
-
-struct nfs4_ace {
-	uint32_t	type;
-	uint32_t	flag;
-	uint32_t	access_mask;
-	int		whotype;
-	union {
-		kuid_t	who_uid;
-		kgid_t	who_gid;
-	};
-};
-
-struct nfs4_acl {
-	uint32_t	naces;
-	struct nfs4_ace	aces[0];
-};
-
-#define NFS4_MAXLABELLEN	2048
-
-struct nfs4_label {
-	uint32_t	lfs;
-	uint32_t	pi;
-	u32		len;
-	char	*label;
-};
-
-typedef struct { char data[NFS4_VERIFIER_SIZE]; } nfs4_verifier;
-
-struct nfs4_stateid_struct {
-	union {
-		char data[NFS4_STATEID_SIZE];
-		struct {
-			__be32 seqid;
-			char other[NFS4_STATEID_OTHER_SIZE];
-		} __attribute__ ((packed));
-	};
-
-	enum {
-		NFS4_INVALID_STATEID_TYPE = 0,
-		NFS4_SPECIAL_STATEID_TYPE,
-		NFS4_OPEN_STATEID_TYPE,
-		NFS4_LOCK_STATEID_TYPE,
-		NFS4_DELEGATION_STATEID_TYPE,
-		NFS4_LAYOUT_STATEID_TYPE,
-		NFS4_PNFS_DS_STATEID_TYPE,
-		NFS4_REVOKED_STATEID_TYPE,
-	} type;
-};
-
-typedef struct nfs4_stateid_struct nfs4_stateid;
-
-enum nfs_opnum4 {
-	OP_ACCESS = 3,
-	OP_CLOSE = 4,
-	OP_COMMIT = 5,
-	OP_CREATE = 6,
-	OP_DELEGPURGE = 7,
-	OP_DELEGRETURN = 8,
-	OP_GETATTR = 9,
-	OP_GETFH = 10,
-	OP_LINK = 11,
-	OP_LOCK = 12,
-	OP_LOCKT = 13,
-	OP_LOCKU = 14,
-	OP_LOOKUP = 15,
-	OP_LOOKUPP = 16,
-	OP_NVERIFY = 17,
-	OP_OPEN = 18,
-	OP_OPENATTR = 19,
-	OP_OPEN_CONFIRM = 20,
-	OP_OPEN_DOWNGRADE = 21,
-	OP_PUTFH = 22,
-	OP_PUTPUBFH = 23,
-	OP_PUTROOTFH = 24,
-	OP_READ = 25,
-	OP_READDIR = 26,
-	OP_READLINK = 27,
-	OP_REMOVE = 28,
-	OP_RENAME = 29,
-	OP_RENEW = 30,
-	OP_RESTOREFH = 31,
-	OP_SAVEFH = 32,
-	OP_SECINFO = 33,
-	OP_SETATTR = 34,
-	OP_SETCLIENTID = 35,
-	OP_SETCLIENTID_CONFIRM = 36,
-	OP_VERIFY = 37,
-	OP_WRITE = 38,
-	OP_RELEASE_LOCKOWNER = 39,
-
-	/* nfs41 */
-	OP_BACKCHANNEL_CTL = 40,
-	OP_BIND_CONN_TO_SESSION = 41,
-	OP_EXCHANGE_ID = 42,
-	OP_CREATE_SESSION = 43,
-	OP_DESTROY_SESSION = 44,
-	OP_FREE_STATEID = 45,
-	OP_GET_DIR_DELEGATION = 46,
-	OP_GETDEVICEINFO = 47,
-	OP_GETDEVICELIST = 48,
-	OP_LAYOUTCOMMIT = 49,
-	OP_LAYOUTGET = 50,
-	OP_LAYOUTRETURN = 51,
-	OP_SECINFO_NO_NAME = 52,
-	OP_SEQUENCE = 53,
-	OP_SET_SSV = 54,
-	OP_TEST_STATEID = 55,
-	OP_WANT_DELEGATION = 56,
-	OP_DESTROY_CLIENTID = 57,
-	OP_RECLAIM_COMPLETE = 58,
-
-	/* nfs42 */
-	OP_ALLOCATE = 59,
-	OP_COPY = 60,
-	OP_COPY_NOTIFY = 61,
-	OP_DEALLOCATE = 62,
-	OP_IO_ADVISE = 63,
-	OP_LAYOUTERROR = 64,
-	OP_LAYOUTSTATS = 65,
-	OP_OFFLOAD_CANCEL = 66,
-	OP_OFFLOAD_STATUS = 67,
-	OP_READ_PLUS = 68,
-	OP_SEEK = 69,
-	OP_WRITE_SAME = 70,
-	OP_CLONE = 71,
-
-	OP_ILLEGAL = 10044,
-};
-
-/*Defining first and last NFS4 operations implemented.
-Needs to be updated if more operations are defined in future.*/
-
-#define FIRST_NFS4_OP	OP_ACCESS
-#define LAST_NFS40_OP	OP_RELEASE_LOCKOWNER
-#define LAST_NFS41_OP	OP_RECLAIM_COMPLETE
-#define LAST_NFS42_OP	OP_CLONE
-#define LAST_NFS4_OP	LAST_NFS42_OP
-
-enum nfsstat4 {
-	NFS4_OK = 0,
-	NFS4ERR_PERM = 1,
-	NFS4ERR_NOENT = 2,
-	NFS4ERR_IO = 5,
-	NFS4ERR_NXIO = 6,
-	NFS4ERR_ACCESS = 13,
-	NFS4ERR_EXIST = 17,
-	NFS4ERR_XDEV = 18,
-	/* Unused/reserved 19 */
-	NFS4ERR_NOTDIR = 20,
-	NFS4ERR_ISDIR = 21,
-	NFS4ERR_INVAL = 22,
-	NFS4ERR_FBIG = 27,
-	NFS4ERR_NOSPC = 28,
-	NFS4ERR_ROFS = 30,
-	NFS4ERR_MLINK = 31,
-	NFS4ERR_NAMETOOLONG = 63,
-	NFS4ERR_NOTEMPTY = 66,
-	NFS4ERR_DQUOT = 69,
-	NFS4ERR_STALE = 70,
-	NFS4ERR_BADHANDLE = 10001,
-	NFS4ERR_BAD_COOKIE = 10003,
-	NFS4ERR_NOTSUPP = 10004,
-	NFS4ERR_TOOSMALL = 10005,
-	NFS4ERR_SERVERFAULT = 10006,
-	NFS4ERR_BADTYPE = 10007,
-	NFS4ERR_DELAY = 10008,
-	NFS4ERR_SAME = 10009,
-	NFS4ERR_DENIED = 10010,
-	NFS4ERR_EXPIRED = 10011,
-	NFS4ERR_LOCKED = 10012,
-	NFS4ERR_GRACE = 10013,
-	NFS4ERR_FHEXPIRED = 10014,
-	NFS4ERR_SHARE_DENIED = 10015,
-	NFS4ERR_WRONGSEC = 10016,
-	NFS4ERR_CLID_INUSE = 10017,
-	NFS4ERR_RESOURCE = 10018,
-	NFS4ERR_MOVED = 10019,
-	NFS4ERR_NOFILEHANDLE = 10020,
-	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
-	NFS4ERR_STALE_CLIENTID = 10022,
-	NFS4ERR_STALE_STATEID = 10023,
-	NFS4ERR_OLD_STATEID = 10024,
-	NFS4ERR_BAD_STATEID = 10025,
-	NFS4ERR_BAD_SEQID = 10026,
-	NFS4ERR_NOT_SAME = 10027,
-	NFS4ERR_LOCK_RANGE = 10028,
-	NFS4ERR_SYMLINK = 10029,
-	NFS4ERR_RESTOREFH = 10030,
-	NFS4ERR_LEASE_MOVED = 10031,
-	NFS4ERR_ATTRNOTSUPP = 10032,
-	NFS4ERR_NO_GRACE = 10033,
-	NFS4ERR_RECLAIM_BAD = 10034,
-	NFS4ERR_RECLAIM_CONFLICT = 10035,
-	NFS4ERR_BADXDR = 10036,
-	NFS4ERR_LOCKS_HELD = 10037,
-	NFS4ERR_OPENMODE = 10038,
-	NFS4ERR_BADOWNER = 10039,
-	NFS4ERR_BADCHAR = 10040,
-	NFS4ERR_BADNAME = 10041,
-	NFS4ERR_BAD_RANGE = 10042,
-	NFS4ERR_LOCK_NOTSUPP = 10043,
-	NFS4ERR_OP_ILLEGAL = 10044,
-	NFS4ERR_DEADLOCK = 10045,
-	NFS4ERR_FILE_OPEN = 10046,
-	NFS4ERR_ADMIN_REVOKED = 10047,
-	NFS4ERR_CB_PATH_DOWN = 10048,
-
-	/* nfs41 */
-	NFS4ERR_BADIOMODE	= 10049,
-	NFS4ERR_BADLAYOUT	= 10050,
-	NFS4ERR_BAD_SESSION_DIGEST = 10051,
-	NFS4ERR_BADSESSION	= 10052,
-	NFS4ERR_BADSLOT		= 10053,
-	NFS4ERR_COMPLETE_ALREADY = 10054,
-	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
-	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
-	NFS4ERR_BACK_CHAN_BUSY	= 10057,	/* backchan reqs outstanding */
-	NFS4ERR_LAYOUTTRYLATER	= 10058,
-	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
-	NFS4ERR_NOMATCHING_LAYOUT = 10060,
-	NFS4ERR_RECALLCONFLICT	= 10061,
-	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
-	NFS4ERR_SEQ_MISORDERED = 10063, 	/* unexpected seq.id in req */
-	NFS4ERR_SEQUENCE_POS	= 10064,	/* [CB_]SEQ. op not 1st op */
-	NFS4ERR_REQ_TOO_BIG	= 10065,	/* request too big */
-	NFS4ERR_REP_TOO_BIG	= 10066,	/* reply too big */
-	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,	/* rep. not all cached */
-	NFS4ERR_RETRY_UNCACHED_REP = 10068,	/* retry & rep. uncached */
-	NFS4ERR_UNSAFE_COMPOUND = 10069,	/* retry/recovery too hard */
-	NFS4ERR_TOO_MANY_OPS	= 10070,	/* too many ops in [CB_]COMP */
-	NFS4ERR_OP_NOT_IN_SESSION = 10071,	/* op needs [CB_]SEQ. op */
-	NFS4ERR_HASH_ALG_UNSUPP = 10072,	/* hash alg. not supp. */
-						/* Error 10073 is unused. */
-	NFS4ERR_CLIENTID_BUSY	= 10074,	/* clientid has state */
-	NFS4ERR_PNFS_IO_HOLE	= 10075,	/* IO to _SPARSE file hole */
-	NFS4ERR_SEQ_FALSE_RETRY	= 10076,	/* retry not original */
-	NFS4ERR_BAD_HIGH_SLOT	= 10077,	/* sequence arg bad */
-	NFS4ERR_DEADSESSION	= 10078,	/* persistent session dead */
-	NFS4ERR_ENCR_ALG_UNSUPP = 10079,	/* SSV alg mismatch */
-	NFS4ERR_PNFS_NO_LAYOUT	= 10080,	/* direct I/O with no layout */
-	NFS4ERR_NOT_ONLY_OP	= 10081,	/* bad compound */
-	NFS4ERR_WRONG_CRED	= 10082,	/* permissions:state change */
-	NFS4ERR_WRONG_TYPE	= 10083,	/* current operation mismatch */
-	NFS4ERR_DIRDELEG_UNAVAIL = 10084,	/* no directory delegation */
-	NFS4ERR_REJECT_DELEG	= 10085,	/* on callback */
-	NFS4ERR_RETURNCONFLICT	= 10086,	/* outstanding layoutreturn */
-	NFS4ERR_DELEG_REVOKED	= 10087,	/* deleg./layout revoked */
-
-	/* nfs42 */
-	NFS4ERR_PARTNER_NOTSUPP	= 10088,
-	NFS4ERR_PARTNER_NO_AUTH	= 10089,
-	NFS4ERR_UNION_NOTSUPP = 10090,
-	NFS4ERR_OFFLOAD_DENIED = 10091,
-	NFS4ERR_WRONG_LFS = 10092,
-	NFS4ERR_BADLABEL = 10093,
-	NFS4ERR_OFFLOAD_NO_REQS = 10094,
-};
-
-static inline bool seqid_mutating_err(u32 err)
-{
-	/* See RFC 7530, section 9.1.7 */
-	switch (err) {
-	case NFS4ERR_STALE_CLIENTID:
-	case NFS4ERR_STALE_STATEID:
-	case NFS4ERR_BAD_STATEID:
-	case NFS4ERR_BAD_SEQID:
-	case NFS4ERR_BADXDR:
-	case NFS4ERR_RESOURCE:
-	case NFS4ERR_NOFILEHANDLE:
-	case NFS4ERR_MOVED:
-		return false;
-	};
-	return true;
-}
-
-/*
- * Note: NF4BAD is not actually part of the protocol; it is just used
- * internally by nfsd.
- */
-enum nfs_ftype4 {
-	NF4BAD		= 0,
-        NF4REG          = 1,    /* Regular File */
-        NF4DIR          = 2,    /* Directory */
-        NF4BLK          = 3,    /* Special File - block device */
-        NF4CHR          = 4,    /* Special File - character device */
-        NF4LNK          = 5,    /* Symbolic Link */
-        NF4SOCK         = 6,    /* Special File - socket */
-        NF4FIFO         = 7,    /* Special File - fifo */
-        NF4ATTRDIR      = 8,    /* Attribute Directory */
-        NF4NAMEDATTR    = 9     /* Named Attribute */
-};
-
-enum open_claim_type4 {
-	NFS4_OPEN_CLAIM_NULL = 0,
-	NFS4_OPEN_CLAIM_PREVIOUS = 1,
-	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
-	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
-	NFS4_OPEN_CLAIM_FH = 4, /* 4.1 */
-	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5, /* 4.1 */
-	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6, /* 4.1 */
-};
-
-enum opentype4 {
-	NFS4_OPEN_NOCREATE = 0,
-	NFS4_OPEN_CREATE = 1
-};
-
-enum createmode4 {
-	NFS4_CREATE_UNCHECKED = 0,
-	NFS4_CREATE_GUARDED = 1,
-	NFS4_CREATE_EXCLUSIVE = 2,
-	/*
-	 * New to NFSv4.1. If session is persistent,
-	 * GUARDED4 MUST be used. Otherwise, use
-	 * EXCLUSIVE4_1 instead of EXCLUSIVE4.
-	 */
-	NFS4_CREATE_EXCLUSIVE4_1 = 3
-};
-
-enum limit_by4 {
-	NFS4_LIMIT_SIZE = 1,
-	NFS4_LIMIT_BLOCKS = 2
-};
-
-enum open_delegation_type4 {
-	NFS4_OPEN_DELEGATE_NONE = 0,
-	NFS4_OPEN_DELEGATE_READ = 1,
-	NFS4_OPEN_DELEGATE_WRITE = 2,
-	NFS4_OPEN_DELEGATE_NONE_EXT = 3, /* 4.1 */
-};
-
-enum why_no_delegation4 { /* new to v4.1 */
-	WND4_NOT_WANTED = 0,
-	WND4_CONTENTION = 1,
-	WND4_RESOURCE = 2,
-	WND4_NOT_SUPP_FTYPE = 3,
-	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
-	WND4_NOT_SUPP_UPGRADE = 5,
-	WND4_NOT_SUPP_DOWNGRADE = 6,
-	WND4_CANCELLED = 7,
-	WND4_IS_DIR = 8,
-};
-
-enum lock_type4 {
-	NFS4_UNLOCK_LT = 0,
-	NFS4_READ_LT = 1,
-	NFS4_WRITE_LT = 2,
-	NFS4_READW_LT = 3,
-	NFS4_WRITEW_LT = 4
-};
-
-
-/* Mandatory Attributes */
-#define FATTR4_WORD0_SUPPORTED_ATTRS    (1UL << 0)
-#define FATTR4_WORD0_TYPE               (1UL << 1)
-#define FATTR4_WORD0_FH_EXPIRE_TYPE     (1UL << 2)
-#define FATTR4_WORD0_CHANGE             (1UL << 3)
-#define FATTR4_WORD0_SIZE               (1UL << 4)
-#define FATTR4_WORD0_LINK_SUPPORT       (1UL << 5)
-#define FATTR4_WORD0_SYMLINK_SUPPORT    (1UL << 6)
-#define FATTR4_WORD0_NAMED_ATTR         (1UL << 7)
-#define FATTR4_WORD0_FSID               (1UL << 8)
-#define FATTR4_WORD0_UNIQUE_HANDLES     (1UL << 9)
-#define FATTR4_WORD0_LEASE_TIME         (1UL << 10)
-#define FATTR4_WORD0_RDATTR_ERROR       (1UL << 11)
-/* Mandatory in NFSv4.1 */
-#define FATTR4_WORD2_SUPPATTR_EXCLCREAT (1UL << 11)
-
-/* Recommended Attributes */
-#define FATTR4_WORD0_ACL                (1UL << 12)
-#define FATTR4_WORD0_ACLSUPPORT         (1UL << 13)
-#define FATTR4_WORD0_ARCHIVE            (1UL << 14)
-#define FATTR4_WORD0_CANSETTIME         (1UL << 15)
-#define FATTR4_WORD0_CASE_INSENSITIVE   (1UL << 16)
-#define FATTR4_WORD0_CASE_PRESERVING    (1UL << 17)
-#define FATTR4_WORD0_CHOWN_RESTRICTED   (1UL << 18)
-#define FATTR4_WORD0_FILEHANDLE         (1UL << 19)
-#define FATTR4_WORD0_FILEID             (1UL << 20)
-#define FATTR4_WORD0_FILES_AVAIL        (1UL << 21)
-#define FATTR4_WORD0_FILES_FREE         (1UL << 22)
-#define FATTR4_WORD0_FILES_TOTAL        (1UL << 23)
-#define FATTR4_WORD0_FS_LOCATIONS       (1UL << 24)
-#define FATTR4_WORD0_HIDDEN             (1UL << 25)
-#define FATTR4_WORD0_HOMOGENEOUS        (1UL << 26)
-#define FATTR4_WORD0_MAXFILESIZE        (1UL << 27)
-#define FATTR4_WORD0_MAXLINK            (1UL << 28)
-#define FATTR4_WORD0_MAXNAME            (1UL << 29)
-#define FATTR4_WORD0_MAXREAD            (1UL << 30)
-#define FATTR4_WORD0_MAXWRITE           (1UL << 31)
-#define FATTR4_WORD1_MIMETYPE           (1UL << 0)
-#define FATTR4_WORD1_MODE               (1UL << 1)
-#define FATTR4_WORD1_NO_TRUNC           (1UL << 2)
-#define FATTR4_WORD1_NUMLINKS           (1UL << 3)
-#define FATTR4_WORD1_OWNER              (1UL << 4)
-#define FATTR4_WORD1_OWNER_GROUP        (1UL << 5)
-#define FATTR4_WORD1_QUOTA_HARD         (1UL << 6)
-#define FATTR4_WORD1_QUOTA_SOFT         (1UL << 7)
-#define FATTR4_WORD1_QUOTA_USED         (1UL << 8)
-#define FATTR4_WORD1_RAWDEV             (1UL << 9)
-#define FATTR4_WORD1_SPACE_AVAIL        (1UL << 10)
-#define FATTR4_WORD1_SPACE_FREE         (1UL << 11)
-#define FATTR4_WORD1_SPACE_TOTAL        (1UL << 12)
-#define FATTR4_WORD1_SPACE_USED         (1UL << 13)
-#define FATTR4_WORD1_SYSTEM             (1UL << 14)
-#define FATTR4_WORD1_TIME_ACCESS        (1UL << 15)
-#define FATTR4_WORD1_TIME_ACCESS_SET    (1UL << 16)
-#define FATTR4_WORD1_TIME_BACKUP        (1UL << 17)
-#define FATTR4_WORD1_TIME_CREATE        (1UL << 18)
-#define FATTR4_WORD1_TIME_DELTA         (1UL << 19)
-#define FATTR4_WORD1_TIME_METADATA      (1UL << 20)
-#define FATTR4_WORD1_TIME_MODIFY        (1UL << 21)
-#define FATTR4_WORD1_TIME_MODIFY_SET    (1UL << 22)
-#define FATTR4_WORD1_MOUNTED_ON_FILEID  (1UL << 23)
-#define FATTR4_WORD1_FS_LAYOUT_TYPES    (1UL << 30)
-#define FATTR4_WORD2_LAYOUT_TYPES       (1UL << 0)
-#define FATTR4_WORD2_LAYOUT_BLKSIZE     (1UL << 1)
-#define FATTR4_WORD2_MDSTHRESHOLD       (1UL << 4)
-#define FATTR4_WORD2_CLONE_BLKSIZE	(1UL << 13)
-#define FATTR4_WORD2_SECURITY_LABEL     (1UL << 16)
-#define FATTR4_WORD2_MODE_UMASK		(1UL << 17)
-
-/* MDS threshold bitmap bits */
-#define THRESHOLD_RD                    (1UL << 0)
-#define THRESHOLD_WR                    (1UL << 1)
-#define THRESHOLD_RD_IO                 (1UL << 2)
-#define THRESHOLD_WR_IO                 (1UL << 3)
-
-#define NFSPROC4_NULL 0
-#define NFSPROC4_COMPOUND 1
-#define NFS4_VERSION 4
-#define NFS4_MINOR_VERSION 0
-
-#define NFS4_DEBUG 1
-
-/* Index of predefined Linux client operations */
-
-enum {
-	NFSPROC4_CLNT_NULL = 0,		/* Unused */
-	NFSPROC4_CLNT_READ,
-	NFSPROC4_CLNT_WRITE,
-	NFSPROC4_CLNT_COMMIT,
-	NFSPROC4_CLNT_OPEN,
-	NFSPROC4_CLNT_OPEN_CONFIRM,
-	NFSPROC4_CLNT_OPEN_NOATTR,
-	NFSPROC4_CLNT_OPEN_DOWNGRADE,
-	NFSPROC4_CLNT_CLOSE,
-	NFSPROC4_CLNT_SETATTR,
-	NFSPROC4_CLNT_FSINFO,
-	NFSPROC4_CLNT_RENEW,
-	NFSPROC4_CLNT_SETCLIENTID,
-	NFSPROC4_CLNT_SETCLIENTID_CONFIRM,
-	NFSPROC4_CLNT_LOCK,
-	NFSPROC4_CLNT_LOCKT,
-	NFSPROC4_CLNT_LOCKU,
-	NFSPROC4_CLNT_ACCESS,
-	NFSPROC4_CLNT_GETATTR,
-	NFSPROC4_CLNT_LOOKUP,
-	NFSPROC4_CLNT_LOOKUP_ROOT,
-	NFSPROC4_CLNT_REMOVE,
-	NFSPROC4_CLNT_RENAME,
-	NFSPROC4_CLNT_LINK,
-	NFSPROC4_CLNT_SYMLINK,
-	NFSPROC4_CLNT_CREATE,
-	NFSPROC4_CLNT_PATHCONF,
-	NFSPROC4_CLNT_STATFS,
-	NFSPROC4_CLNT_READLINK,
-	NFSPROC4_CLNT_READDIR,
-	NFSPROC4_CLNT_SERVER_CAPS,
-	NFSPROC4_CLNT_DELEGRETURN,
-	NFSPROC4_CLNT_GETACL,
-	NFSPROC4_CLNT_SETACL,
-	NFSPROC4_CLNT_FS_LOCATIONS,
-	NFSPROC4_CLNT_RELEASE_LOCKOWNER,
-	NFSPROC4_CLNT_SECINFO,
-	NFSPROC4_CLNT_FSID_PRESENT,
-
-	/* nfs41 */
-	NFSPROC4_CLNT_EXCHANGE_ID,
-	NFSPROC4_CLNT_CREATE_SESSION,
-	NFSPROC4_CLNT_DESTROY_SESSION,
-	NFSPROC4_CLNT_SEQUENCE,
-	NFSPROC4_CLNT_GET_LEASE_TIME,
-	NFSPROC4_CLNT_RECLAIM_COMPLETE,
-	NFSPROC4_CLNT_LAYOUTGET,
-	NFSPROC4_CLNT_GETDEVICEINFO,
-	NFSPROC4_CLNT_LAYOUTCOMMIT,
-	NFSPROC4_CLNT_LAYOUTRETURN,
-	NFSPROC4_CLNT_SECINFO_NO_NAME,
-	NFSPROC4_CLNT_TEST_STATEID,
-	NFSPROC4_CLNT_FREE_STATEID,
-	NFSPROC4_CLNT_GETDEVICELIST,
-	NFSPROC4_CLNT_BIND_CONN_TO_SESSION,
-	NFSPROC4_CLNT_DESTROY_CLIENTID,
-
-	/* nfs42 */
-	NFSPROC4_CLNT_SEEK,
-	NFSPROC4_CLNT_ALLOCATE,
-	NFSPROC4_CLNT_DEALLOCATE,
-	NFSPROC4_CLNT_LAYOUTSTATS,
-	NFSPROC4_CLNT_CLONE,
-	NFSPROC4_CLNT_COPY,
-};
-
-/* nfs41 types */
-struct nfs4_sessionid {
-	unsigned char data[NFS4_MAX_SESSIONID_LEN];
-};
-
-/* Create Session Flags */
-#define SESSION4_PERSIST	0x001
-#define SESSION4_BACK_CHAN	0x002
-#define SESSION4_RDMA		0x004
-
-#define SESSION4_FLAG_MASK_A	0x007
-
-enum state_protect_how4 {
-	SP4_NONE	= 0,
-	SP4_MACH_CRED	= 1,
-	SP4_SSV		= 2
-};
-
-enum pnfs_layouttype {
-	LAYOUT_NFSV4_1_FILES  = 1,
-	LAYOUT_OSD2_OBJECTS = 2,
-	LAYOUT_BLOCK_VOLUME = 3,
-	LAYOUT_FLEX_FILES = 4,
-	LAYOUT_SCSI = 5,
-	LAYOUT_TYPE_MAX
-};
-
-/* used for both layout return and recall */
-enum pnfs_layoutreturn_type {
-	RETURN_FILE = 1,
-	RETURN_FSID = 2,
-	RETURN_ALL  = 3
-};
-
-enum pnfs_iomode {
-	IOMODE_READ = 1,
-	IOMODE_RW = 2,
-	IOMODE_ANY = 3,
-};
-
-enum pnfs_notify_deviceid_type4 {
-	NOTIFY_DEVICEID4_CHANGE = 1 << 1,
-	NOTIFY_DEVICEID4_DELETE = 1 << 2,
-};
-
-enum pnfs_block_volume_type {
-	PNFS_BLOCK_VOLUME_SIMPLE	= 0,
-	PNFS_BLOCK_VOLUME_SLICE		= 1,
-	PNFS_BLOCK_VOLUME_CONCAT	= 2,
-	PNFS_BLOCK_VOLUME_STRIPE	= 3,
-	PNFS_BLOCK_VOLUME_SCSI		= 4,
-};
-
-enum pnfs_block_extent_state {
-	PNFS_BLOCK_READWRITE_DATA	= 0,
-	PNFS_BLOCK_READ_DATA		= 1,
-	PNFS_BLOCK_INVALID_DATA		= 2,
-	PNFS_BLOCK_NONE_DATA		= 3,
-};
-
-/* on the wire size of a block layout extent */
-#define PNFS_BLOCK_EXTENT_SIZE \
-	(7 * sizeof(__be32) + NFS4_DEVICEID4_SIZE)
-
-/* on the wire size of a scsi commit range */
-#define PNFS_SCSI_RANGE_SIZE \
-	(4 * sizeof(__be32))
-
-enum scsi_code_set {
-	PS_CODE_SET_BINARY	= 1,
-	PS_CODE_SET_ASCII	= 2,
-	PS_CODE_SET_UTF8	= 3
-};
-
-enum scsi_designator_type {
-	PS_DESIGNATOR_T10	= 1,
-	PS_DESIGNATOR_EUI64	= 2,
-	PS_DESIGNATOR_NAA	= 3,
-	PS_DESIGNATOR_NAME	= 8
-};
-
-#define NFL4_UFLG_MASK			0x0000003F
-#define NFL4_UFLG_DENSE			0x00000001
-#define NFL4_UFLG_COMMIT_THRU_MDS	0x00000002
-#define NFL4_UFLG_STRIPE_UNIT_SIZE_MASK	0xFFFFFFC0
-
-/* Encoded in the loh_body field of type layouthint4 */
-enum filelayout_hint_care4 {
-	NFLH4_CARE_DENSE		= NFL4_UFLG_DENSE,
-	NFLH4_CARE_COMMIT_THRU_MDS	= NFL4_UFLG_COMMIT_THRU_MDS,
-	NFLH4_CARE_STRIPE_UNIT_SIZE	= 0x00000040,
-	NFLH4_CARE_STRIPE_COUNT		= 0x00000080
-};
-
-#define NFS4_DEVICEID4_SIZE 16
-
-struct nfs4_deviceid {
-	char data[NFS4_DEVICEID4_SIZE];
-};
-
-enum data_content4 {
-	NFS4_CONTENT_DATA		= 0,
-	NFS4_CONTENT_HOLE		= 1,
-};
-
-enum pnfs_update_layout_reason {
-	PNFS_UPDATE_LAYOUT_UNKNOWN = 0,
-	PNFS_UPDATE_LAYOUT_NO_PNFS,
-	PNFS_UPDATE_LAYOUT_RD_ZEROLEN,
-	PNFS_UPDATE_LAYOUT_MDSTHRESH,
-	PNFS_UPDATE_LAYOUT_NOMEM,
-	PNFS_UPDATE_LAYOUT_BULK_RECALL,
-	PNFS_UPDATE_LAYOUT_IO_TEST_FAIL,
-	PNFS_UPDATE_LAYOUT_FOUND_CACHED,
-	PNFS_UPDATE_LAYOUT_RETURN,
-	PNFS_UPDATE_LAYOUT_RETRY,
-	PNFS_UPDATE_LAYOUT_BLOCKED,
-	PNFS_UPDATE_LAYOUT_INVALID_OPEN,
-	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET,
-};
-
-#endif
diff --git a/bundle/include/linux/nfs_fs_i.h b/bundle/include/linux/nfs_fs_i.h
deleted file mode 100644
index a5c50d973..000000000
--- a/bundle/include/linux/nfs_fs_i.h
+++ /dev/null
@@ -1,20 +0,0 @@
-#ifndef _NFS_FS_I
-#define _NFS_FS_I
-
-struct nlm_lockowner;
-
-/*
- * NFS lock info
- */
-struct nfs_lock_info {
-	u32		state;
-	struct nlm_lockowner *owner;
-	struct list_head list;
-};
-
-struct nfs4_lock_state;
-struct nfs4_lock_info {
-	struct nfs4_lock_state *owner;
-};
-
-#endif
diff --git a/bundle/include/linux/nfs_iostat.h b/bundle/include/linux/nfs_iostat.h
deleted file mode 100644
index 9dcbbe9a5..000000000
--- a/bundle/include/linux/nfs_iostat.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- *  User-space visible declarations for NFS client per-mount
- *  point statistics
- *
- *  Copyright (C) 2005, 2006 Chuck Lever <cel@netapp.com>
- *
- *  NFS client per-mount statistics provide information about the
- *  health of the NFS client and the health of each NFS mount point.
- *  Generally these are not for detailed problem diagnosis, but
- *  simply to indicate that there is a problem.
- *
- *  These counters are not meant to be human-readable, but are meant
- *  to be integrated into system monitoring tools such as "sar" and
- *  "iostat".  As such, the counters are sampled by the tools over
- *  time, and are never zeroed after a file system is mounted.
- *  Moving averages can be computed by the tools by taking the
- *  difference between two instantaneous samples  and dividing that
- *  by the time between the samples.
- */
-
-#ifndef _LINUX_NFS_IOSTAT
-#define _LINUX_NFS_IOSTAT
-
-#define NFS_IOSTAT_VERS		"1.1"
-
-/*
- * NFS byte counters
- *
- * 1.  SERVER - the number of payload bytes read from or written
- *     to the server by the NFS client via an NFS READ or WRITE
- *     request.
- *
- * 2.  NORMAL - the number of bytes read or written by applications
- *     via the read(2) and write(2) system call interfaces.
- *
- * 3.  DIRECT - the number of bytes read or written from files
- *     opened with the O_DIRECT flag.
- *
- * These counters give a view of the data throughput into and out
- * of the NFS client.  Comparing the number of bytes requested by
- * an application with the number of bytes the client requests from
- * the server can provide an indication of client efficiency
- * (per-op, cache hits, etc).
- *
- * These counters can also help characterize which access methods
- * are in use.  DIRECT by itself shows whether there is any O_DIRECT
- * traffic.  NORMAL + DIRECT shows how much data is going through
- * the system call interface.  A large amount of SERVER traffic
- * without much NORMAL or DIRECT traffic shows that applications
- * are using mapped files.
- *
- * NFS page counters
- *
- * These count the number of pages read or written via nfs_readpage(),
- * nfs_readpages(), or their write equivalents.
- *
- * NB: When adding new byte counters, please include the measured
- * units in the name of each byte counter to help users of this
- * interface determine what exactly is being counted.
- */
-enum nfs_stat_bytecounters {
-	NFSIOS_NORMALREADBYTES = 0,
-	NFSIOS_NORMALWRITTENBYTES,
-	NFSIOS_DIRECTREADBYTES,
-	NFSIOS_DIRECTWRITTENBYTES,
-	NFSIOS_SERVERREADBYTES,
-	NFSIOS_SERVERWRITTENBYTES,
-	NFSIOS_READPAGES,
-	NFSIOS_WRITEPAGES,
-	__NFSIOS_BYTESMAX,
-};
-
-/*
- * NFS event counters
- *
- * These counters provide a low-overhead way of monitoring client
- * activity without enabling NFS trace debugging.  The counters
- * show the rate at which VFS requests are made, and how often the
- * client invalidates its data and attribute caches.  This allows
- * system administrators to monitor such things as how close-to-open
- * is working, and answer questions such as "why are there so many
- * GETATTR requests on the wire?"
- *
- * They also count anamolous events such as short reads and writes,
- * silly renames due to close-after-delete, and operations that
- * change the size of a file (such operations can often be the
- * source of data corruption if applications aren't using file
- * locking properly).
- */
-enum nfs_stat_eventcounters {
-	NFSIOS_INODEREVALIDATE = 0,
-	NFSIOS_DENTRYREVALIDATE,
-	NFSIOS_DATAINVALIDATE,
-	NFSIOS_ATTRINVALIDATE,
-	NFSIOS_VFSOPEN,
-	NFSIOS_VFSLOOKUP,
-	NFSIOS_VFSACCESS,
-	NFSIOS_VFSUPDATEPAGE,
-	NFSIOS_VFSREADPAGE,
-	NFSIOS_VFSREADPAGES,
-	NFSIOS_VFSWRITEPAGE,
-	NFSIOS_VFSWRITEPAGES,
-	NFSIOS_VFSGETDENTS,
-	NFSIOS_VFSSETATTR,
-	NFSIOS_VFSFLUSH,
-	NFSIOS_VFSFSYNC,
-	NFSIOS_VFSLOCK,
-	NFSIOS_VFSRELEASE,
-	NFSIOS_CONGESTIONWAIT,
-	NFSIOS_SETATTRTRUNC,
-	NFSIOS_EXTENDWRITE,
-	NFSIOS_SILLYRENAME,
-	NFSIOS_SHORTREAD,
-	NFSIOS_SHORTWRITE,
-	NFSIOS_DELAY,
-	NFSIOS_PNFS_READ,
-	NFSIOS_PNFS_WRITE,
-	__NFSIOS_COUNTSMAX,
-};
-
-/*
- * NFS local caching servicing counters
- */
-enum nfs_stat_fscachecounters {
-	NFSIOS_FSCACHE_PAGES_READ_OK,
-	NFSIOS_FSCACHE_PAGES_READ_FAIL,
-	NFSIOS_FSCACHE_PAGES_WRITTEN_OK,
-	NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL,
-	NFSIOS_FSCACHE_PAGES_UNCACHED,
-	__NFSIOS_FSCACHEMAX,
-};
-
-#endif	/* _LINUX_NFS_IOSTAT */
diff --git a/bundle/include/linux/nfs_page.h b/bundle/include/linux/nfs_page.h
deleted file mode 100644
index 57b2f3acb..000000000
--- a/bundle/include/linux/nfs_page.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * linux/include/linux/nfs_page.h
- *
- * Copyright (C) 2000 Trond Myklebust
- *
- * NFS page cache wrapper.
- */
-
-#ifndef _LINUX_NFS_PAGE_H
-#define _LINUX_NFS_PAGE_H
-
-
-#include <linux/list.h>
-#include <linux/pagemap.h>
-#include <linux/wait.h>
-#include <linux/sunrpc/auth.h>
-#include <linux/nfs_xdr.h>
-
-#include <linux/kref.h>
-
-/*
- * Valid flags for a dirty buffer
- */
-enum {
-	PG_BUSY = 0,		/* nfs_{un}lock_request */
-	PG_MAPPED,		/* page private set for buffered io */
-	PG_CLEAN,		/* write succeeded */
-	PG_COMMIT_TO_DS,	/* used by pnfs layouts */
-	PG_INODE_REF,		/* extra ref held by inode when in writeback */
-	PG_HEADLOCK,		/* page group lock of wb_head */
-	PG_TEARDOWN,		/* page group sync for destroy */
-	PG_UNLOCKPAGE,		/* page group sync bit in read path */
-	PG_UPTODATE,		/* page group sync bit in read path */
-	PG_WB_END,		/* page group sync bit in write path */
-	PG_REMOVE,		/* page group sync bit in write path */
-};
-
-struct nfs_inode;
-struct nfs_page {
-	struct list_head	wb_list;	/* Defines state of page: */
-	struct page		*wb_page;	/* page to read in/write out */
-	struct nfs_open_context	*wb_context;	/* File state context info */
-	struct nfs_lock_context	*wb_lock_context;	/* lock context info */
-	pgoff_t			wb_index;	/* Offset >> PAGE_CACHE_SHIFT */
-	unsigned int		wb_offset,	/* Offset & ~PAGE_CACHE_MASK */
-				wb_pgbase,	/* Start of page data */
-				wb_bytes;	/* Length of request */
-	struct kref		wb_kref;	/* reference count */
-	unsigned long		wb_flags;
-	struct nfs_write_verifier	wb_verf;	/* Commit cookie */
-	struct nfs_page		*wb_this_page;  /* list of reqs for this page */
-	struct nfs_page		*wb_head;       /* head pointer for req list */
-};
-
-struct nfs_pageio_descriptor;
-struct nfs_pageio_ops {
-	void	(*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
-	size_t	(*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *,
-			   struct nfs_page *);
-	int	(*pg_doio)(struct nfs_pageio_descriptor *);
-	unsigned int	(*pg_get_mirror_count)(struct nfs_pageio_descriptor *,
-				       struct nfs_page *);
-	void	(*pg_cleanup)(struct nfs_pageio_descriptor *);
-};
-
-struct nfs_rw_ops {
-	struct nfs_pgio_header *(*rw_alloc_header)(void);
-	void (*rw_free_header)(struct nfs_pgio_header *);
-	int  (*rw_done)(struct rpc_task *, struct nfs_pgio_header *,
-			struct inode *);
-	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
-	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *,
-			    const struct nfs_rpc_ops *,
-			    struct rpc_task_setup *, int);
-};
-
-struct nfs_pgio_mirror {
-	struct list_head	pg_list;
-	unsigned long		pg_bytes_written;
-	size_t			pg_count;
-	size_t			pg_bsize;
-	unsigned int		pg_base;
-	unsigned char		pg_recoalesce : 1;
-};
-
-struct nfs_pageio_descriptor {
-	unsigned char		pg_moreio : 1;
-	struct inode		*pg_inode;
-	const struct nfs_pageio_ops *pg_ops;
-	const struct nfs_rw_ops *pg_rw_ops;
-	int 			pg_ioflags;
-	int			pg_error;
-	const struct rpc_call_ops *pg_rpc_callops;
-	const struct nfs_pgio_completion_ops *pg_completion_ops;
-	struct pnfs_layout_segment *pg_lseg;
-	struct nfs_direct_req	*pg_dreq;
-	void			*pg_layout_private;
-	unsigned int		pg_bsize;	/* default bsize for mirrors */
-
-	u32			pg_mirror_count;
-	struct nfs_pgio_mirror	*pg_mirrors;
-	struct nfs_pgio_mirror	pg_mirrors_static[1];
-	struct nfs_pgio_mirror	*pg_mirrors_dynamic;
-	u32			pg_mirror_idx;	/* current mirror */
-};
-
-/* arbitrarily selected limit to number of mirrors */
-#define NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX 16
-
-#define NFS_WBACK_BUSY(req)	(test_bit(PG_BUSY,&(req)->wb_flags))
-
-extern	struct nfs_page *nfs_create_request(struct nfs_open_context *ctx,
-					    struct page *page,
-					    struct nfs_page *last,
-					    unsigned int offset,
-					    unsigned int count);
-extern	void nfs_release_request(struct nfs_page *);
-
-
-extern	void nfs_pageio_init(struct nfs_pageio_descriptor *desc,
-			     struct inode *inode,
-			     const struct nfs_pageio_ops *pg_ops,
-			     const struct nfs_pgio_completion_ops *compl_ops,
-			     const struct nfs_rw_ops *rw_ops,
-			     size_t bsize,
-			     int how,
-			     gfp_t gfp_flags);
-extern	int nfs_pageio_add_request(struct nfs_pageio_descriptor *,
-				   struct nfs_page *);
-extern  int nfs_pageio_resend(struct nfs_pageio_descriptor *,
-			      struct nfs_pgio_header *);
-extern	void nfs_pageio_complete(struct nfs_pageio_descriptor *desc);
-extern	void nfs_pageio_cond_complete(struct nfs_pageio_descriptor *, pgoff_t);
-extern size_t nfs_generic_pg_test(struct nfs_pageio_descriptor *desc,
-				struct nfs_page *prev,
-				struct nfs_page *req);
-extern  int nfs_wait_on_request(struct nfs_page *);
-extern	void nfs_unlock_request(struct nfs_page *req);
-extern	void nfs_unlock_and_release_request(struct nfs_page *);
-extern int nfs_page_group_lock(struct nfs_page *, bool);
-extern void nfs_page_group_lock_wait(struct nfs_page *);
-extern void nfs_page_group_unlock(struct nfs_page *);
-extern bool nfs_page_group_sync_on_bit(struct nfs_page *, unsigned int);
-extern bool nfs_async_iocounter_wait(struct rpc_task *, struct nfs_lock_context *);
-
-/*
- * Lock the page of an asynchronous request
- */
-static inline int
-nfs_lock_request(struct nfs_page *req)
-{
-	return !test_and_set_bit(PG_BUSY, &req->wb_flags);
-}
-
-/**
- * nfs_list_add_request - Insert a request into a list
- * @req: request
- * @head: head of list into which to insert the request.
- */
-static inline void
-nfs_list_add_request(struct nfs_page *req, struct list_head *head)
-{
-	list_add_tail(&req->wb_list, head);
-}
-
-
-/**
- * nfs_list_remove_request - Remove a request from its wb_list
- * @req: request
- */
-static inline void
-nfs_list_remove_request(struct nfs_page *req)
-{
-	if (list_empty(&req->wb_list))
-		return;
-	list_del_init(&req->wb_list);
-}
-
-static inline struct nfs_page *
-nfs_list_entry(struct list_head *head)
-{
-	return list_entry(head, struct nfs_page, wb_list);
-}
-
-static inline
-loff_t req_offset(struct nfs_page *req)
-{
-	return (((loff_t)req->wb_index) << PAGE_CACHE_SHIFT) + req->wb_offset;
-}
-
-#endif /* _LINUX_NFS_PAGE_H */
diff --git a/bundle/include/linux/nfsacl.h b/bundle/include/linux/nfsacl.h
deleted file mode 100644
index 5e69e67b3..000000000
--- a/bundle/include/linux/nfsacl.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * File: linux/nfsacl.h
- *
- * (C) 2003 Andreas Gruenbacher <agruen@suse.de>
- */
-#ifndef __LINUX_NFSACL_H
-#define __LINUX_NFSACL_H
-
-
-#include <linux/posix_acl.h>
-#include <linux/sunrpc/xdr.h>
-#include <uapi/linux/nfsacl.h>
-
-/* Maximum number of ACL entries over NFS */
-#define NFS_ACL_MAX_ENTRIES	1024
-
-#define NFSACL_MAXWORDS		(2*(2+3*NFS_ACL_MAX_ENTRIES))
-#define NFSACL_MAXPAGES		((2*(8+12*NFS_ACL_MAX_ENTRIES) + PAGE_SIZE-1) \
-				 >> PAGE_SHIFT)
-
-#define NFS_ACL_MAX_ENTRIES_INLINE	(5)
-#define NFS_ACL_INLINE_BUFSIZE	((2*(2+3*NFS_ACL_MAX_ENTRIES_INLINE)) << 2)
-
-static inline unsigned int
-nfsacl_size(struct posix_acl *acl_access, struct posix_acl *acl_default)
-{
-	unsigned int w = 16;
-	w += max(acl_access ? (int)acl_access->a_count : 3, 4) * 12;
-	if (acl_default)
-		w += max((int)acl_default->a_count, 4) * 12;
-	return w;
-}
-
-extern int
-nfsacl_encode(struct xdr_buf *buf, unsigned int base, struct inode *inode,
-	      struct posix_acl *acl, int encode_entries, int typeflag);
-extern int
-nfsacl_decode(struct xdr_buf *buf, unsigned int base, unsigned int *aclcnt,
-	      struct posix_acl **pacl);
-
-#endif  /* __LINUX_NFSACL_H */
diff --git a/take-bundle.sh b/take-bundle.sh
index 83bdce81d..f93c38d0d 100755
--- a/take-bundle.sh
+++ b/take-bundle.sh
@@ -66,7 +66,7 @@ if [[ "$mode" == "links" ]] ; then
 else
 	${CP_CMD} ${linux_source}/include/linux/lockd ${new_bundle}/include/linux/
 fi
-${CP_CMD} ${linux_source}/include/linux/nfs*.h ${new_bundle}/include/linux/
+${CP_CMD} ${linux_source}/include/linux/{nfs_fs.h,nfs_fs_sb.h,nfs_xdr.h} ${new_bundle}/include/linux/
 if [[ -e ${linux_source}/include/linux/old-kernel.h ]] ; then
     ${CP_CMD} ${linux_source}/include/linux/old-kernel.h ${new_bundle}/include/linux/
 fi
